# jis2ucs.binについて
`jis2ucs.bin`は[`jis2ucs.yml`](https://github.com/aozorahack/aozora2html/blob/master/yml/jis2ucs.yml)をバイナリ形式にしたものです。
ファイル構造は、各4バイト・2\*94\*94の3次元配列です。
先頭4バイトは`FE FF 00 00`にしています。
これはUTF-8のBOMに相当するものです。

つまり面句点番号をa-b-cとした場合、`(((a-1)*94+(b-1))*94+c)*4`バイト目に要素があります。
仕様上、多くの領域は空白です。

## 実体参照表現
`jis2ucs.yml`においてJIS X 0213の文字を実体参照した場合は以下の3種類で表現されます。

1. `&#x****;` (16進4桁1文字)
2. `&#x2****;` (16進5桁1文字/サロゲートペア)
3. `&#x****;&#x****;` (16進4桁2文字)

全ての要素で`&#x000*;`に該当する文字は(制御文字なので)ありません。
2.の場合16進数部分の先頭は必ず2です。
また全て16進数大文字0埋め4桁以上で表現されています。

## 各要素の記述
各要素は2バイト毎にリトルエンディアンで表現されます。
また上の3種類に対して以下のように記述されます。

### 1. `&#x****;` (16進4桁1文字)
1. 前半2バイトは`00 00`固定です。
2. 後半2バイトはリトルエンディアンで16進数1～4桁目が表現されます。

つまり`&#xABCD;`の場合、`00 00 CD AB`と表現されます。

UTF-16と同じ表現でBOMもあるので、バイナリエディタで適切に表示されます。

### 2. `&#x2****;` (16進5桁1文字/サロゲートペア)
1. 前半2バイトは`02 00`固定です。
2. 後半2バイトはリトルエンディアンで16進数2～5桁目が表現されます。

つまり`&#x2ABCD;`の場合、`02 00 CD AB`と表現されます。

UTF-16と異なる表現なので、バイナリエディタでは適切に表現されません。
このプログラムでは`jis2ucs.yml`と同じ表現を確実に復元することを目的としているので、単なる16進数表現として扱っています。
また仕様上は先頭は1～Fのいずれでも対応可能です。

### 3. `&#x****;&#x****;` (16進4桁2文字)
1. 前半2バイトはリトルエンディアンで1文字目16進数1～4桁目が表現されます。
2. 後半2バイトはリトルエンディアンで2文字目16進数1～4桁目が表現されます。

つまり`&#x1234;&#xABCD;`の場合、`34 12 CD AB`と表現されます。

UTF-16と同じ表現でBOMもあるので、バイナリエディタで適切に表示されます。
半濁点付きのひらがな・カタカナが該当するようです。

### 空白要素
該当する要素が存在しない番号は`00 00 00 00`で表現されます。

## jis2ucs.gz
空白が多いので、gzipで圧縮を行っています。
埋め込みリソースの仕様上`jis2ucs.bin.gz`ではなく`jis2ucs.gz`のファイル名にしています。

ファイルサイズは22,278バイトです。

## 改善案
いくつか改善しうる点があります。

### ビッグエンディアン
バイナリエディタで覗く場合、ビッグエンディアンの方が分かりやすいのでそうすれば良かった気がします。
ファイル作成が少し楽だったのでこうしただけで、特にリトルエンディアンにする理由があった訳ではありません。
なお参照はバイト単位で行っているので、エンディアンが異なる環境でも正常に動作します。

### 容量削減
現時点では一要素に必ず4バイト使用している、また空白は0埋めで表現されているので非効率です。
検索したところ、`jis2ucs.yml`には16進数表現1桁目がA～Eの文字は存在しないので、特殊処理に使えます。
具体的には以下のような仕様が考えられます。

* 各要素4バイトではなく2バイト使う。
* 16進数1桁目がAの場合、空白要素として扱う。
* 16進数1桁目がB～Eの場合、`B000`分減らし`0000`～`3FFF`の数値として扱い、2倍し、ファイル先頭から当該バイト離れた位置を参照する。
* 参照先は空白要素。連続した6バイトを用いる。`A000`分減らし、3桁*3で表現する

`3FFF`は16383です。
この場合のファイルサイズは35,344バイトなので、ほぼ全域を表現できます。
確認していませんが、おそらく空白要素の数は足りると思います。
空白要素に詰め込むのではなく、全要素が終わってから表現しても構わないと思います。

現時点ではたかだか35kbをそこまでして節約する必要を感じていないのでこうしていません。
加えてここまでしてもgzip圧縮よりわずかに大きなサイズになります。
